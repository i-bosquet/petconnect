package com.petconnect.backend.certificate.domain.model;

import com.petconnect.backend.user.domain.model.BaseEntity;
import com.petconnect.backend.pet.domain.model.Pet;
import com.petconnect.backend.record.domain.model.Record;
import com.petconnect.backend.user.domain.model.Clinic;
import com.petconnect.backend.user.domain.model.Vet;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;

/**
 * Represents a digital health certificate generated for a Pet.
 * Contains the payload data (as JSON), cryptographic hash and signatures,
 * and links to the associated Pet, Vet, Clinic, and originating Record.
 * Inherits auditing fields from BaseEntity.
 *
 * @author ibosquet
 */
@Getter
@Setter
@ToString(callSuper = true, exclude = {"pet", "medicalRecord", "generatorVet", "issuingClinic"})
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "certificate")
public class Certificate extends BaseEntity {

    /**
     * The payload of the certificate containing relevant data (pet, owner, vet, clinic, record/vaccine details, dates).
     * Stored as a JSON string for flexibility. Cannot be blank.
     */
    @NotBlank(message = "Certificate payload cannot be blank")
    @Column(name = "payload", nullable = false, columnDefinition = "TEXT")
    private String payload;

    /**
     * Cryptographic hash (e.g., SHA-256) of the payload.
     * Used for integrity verification and as part of the signing process.
     * Stored typically as a hex or Base64 string. Cannot be blank.
     */
    @NotBlank(message = "Payload hash cannot be blank")
    @Column(name = "hash", nullable = false, unique = true)
    private String hash;

    /**
     * The digital signature generated by the veterinarian who issued the certificate.
     * Created by signing the payload hash with the Vet's private key.
     * Stored as a Base64 encoded string. Cannot be blank once generated.
     */
    @NotBlank(message = "Vet signature cannot be blank")
    @Column(name = "vet_signature", nullable = false, columnDefinition = "TEXT")
    private String vetSignature;

    /**
     * The digital signature generated by the issuing clinic.
     * Created by signing the payload hash with the Clinic's private key.
     * Stored as a Base64 encoded string. Cannot be blank once generated.
     */
    @NotBlank(message = "Clinic signature cannot be blank")
    @Column(name = "clinic_signature", nullable = false, columnDefinition = "TEXT")
    private String clinicSignature;

    /**
     * The official certificate number assigned (e.g., AHC number).
     * This number is obtained externally based on regulations.
     * Must be unique. Cannot be blank.
     */
    @NotBlank(message = "Certificate number cannot be blank")
    @Column(name = "certificate_number", nullable = false, unique = true)
    private String certificateNumber;

    // --- Relationships ---

    /**
     * The Pet to whom this certificate applies. Mandatory.
     * Many Certificates can belong to one Pet.
     */
    @NotNull(message = "Certificate must be associated with a Pet")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "pet_id", nullable = false, foreignKey = @ForeignKey(name = "fk_certificate_pet"))
    private Pet pet;

    /**
     * The specific medical Record (often a VACCINE record) based on which this certificate was generated. Mandatory.
     * Many Certificates can potentially originate from one Record (though business logic might restrict to 1:1).
     * Renamed from 'record' to avoid keyword conflict. Corresponds to 'Includes' relationship.
     */
    @NotNull(message = "Certificate must originate from a Record")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "record_id", nullable = false, foreignKey = @ForeignKey(name = "fk_certificate_record"))
    private Record medicalRecord;

    /**
     * The Veterinarian who generated and signed this certificate. Mandatory.
     * Corresponds to 'GeneratedBy' relationship.
     */
    @NotNull(message = "Certificate must have a generating Vet")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "generator_vet_id", nullable = false, foreignKey = @ForeignKey(name = "fk_certificate_vet"))
    private Vet generatorVet;

    /**
     * The Clinic from which this certificate was issued and signed. Mandatory.
     * Corresponds to the 'SignedBy' relationship (interpreted as clinic signature origin).
     */
    @NotNull(message = "Certificate must have an issuing Clinic")
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "issuing_clinic_id", nullable = false, foreignKey = @ForeignKey(name = "fk_certificate_clinic"))
    private Clinic issuingClinic;
}
